4η εργασία Εισαγωγή στον Προγραμματισμό 2022-2023


# NOTE
Η εργασία έγινε ομαδικά απο τους:
sdi2200014 Ζήσιμος Βακράς
sdi2200122 Ιωάννης Ξηρός
ισότιμα, και οι δυό μας έχουμε πλήρη γνώση της υλοποίησης.
(Κάθε γραμμή έχει γραφτεί συλλογικά)
Το πρόγραμμα γίνεται compile με `make` και βρίσκεται στο '/target/crossw'
Στην εργασία αυτή μας βοήθησε πολύ το paper του Stanford πάνω στα csp crosswords
και το paper του P.Prosser πάνω στις τεχνικές labeling και unlabeling των variables σε csp
1. https://web.stanford.edu/~jduchi/projects/crossword_writeup.pdf
2. P. Prosser. Hybrid Algorithms for the Constraint Satisfaction Problem.
Computational Intelligence, Volume 9, Number 3. 1993.
Επίσης μας βοήθησε πολυ και ο στεφ (το rubber ducky μας) και τον ευχαριστούμε πολύ.


# Υλοποίηση
## Αναπαράσταση του σταυρόλεξου


Το σταυρόλεξο μας είναι ενας δισδιάστατος πίνακας char (char**) στον οποίο
τα κελιά που θα μπουν γραμματα αρχικοποιουνται σε '\0' και τα μαύρα κελια
σε '\r'. Ο λόγος που επιλέξαμε αυτά τα chars είναι γιατί το πρόγραμμα 
υποστηρίζει χαρακτήρες όλου του ascii table και αυτοι οι δυο δεν θα υπαρχουν 
σε κάποια λεξη του λεξικού.


## Λεξικό 


Αρχικά δεσμεύουμε χώρο για να φορτωθεί όλο το αρχείο λεξικού στη μνήμη και στη συνέχεια 
ταξινομούμε τις λέξεις κατά μήκος σε υπολεξικά. Όσες λέξεις δεν θα χρειαστούν 
στη λύση δεν εκχωρούνται πουθενα και απλά γίνονται free στο τελος του
προγραμματος. Στη συνεχεια ταξινομούμε τα υπολεξικά βάσει τη συχνότητα 
εμφάνισης των γραμμάτων (για τα μήκη λέξεων που μας ενδιαφέρουν).


## Χαρτογράφηση του λεξικού 


Για τη γρήγορη αναζήτηση λέξεων στο λεξικό έχουμε δημιουργήσει packed bit 
arrays ή αλλιώς bitmaps στα οποια το καθε bit αναπαριστά μια λέξη (index) 
σε ενα υπολεξικό, τα bitmaps αυτά έχουν type long long το οποίο μας δίνει 
την δυνατότητα σε ενα 64bit σύστημα να φορτώσουμε (σε έναν κύκλο μηχανής)
όλο τον αριθμό και να κάνουμε γρήγορα πράξεις bitwise-and(&).
Τα bitmaps αποτελούν τον πυρηνα του προγραμματος καθως αποτελουν αμεση 
αναπαρασταση του domain μιας λεξης.


## Χαρτογράφηση του σταυρόλεξου


Για να χαρτογραφήσουμε τις λέξεις πάνω στο σταυρόλεξο χρησιμοποιούμε structs
τα οποία κρατάνε όσες πληροφορίες μας ειναι χρήσιμες για τη λύση (για παραπάνω 
πληροφορίες δείτε την υλοποίηση). Σημαντικό είναι ότι κρατάμε και τα intersections
κάθε λέξης σε ενα array για να μας βοηθήσουν στο fc-cbj που θα αναφέρουμε αργότερα.


## Λύση του σταυρόλεξου 


Ο αλγόριθμος που χρησιμοποιούμε είναι μια μίξη των τεχνικών:
- cbj (conflict-directed backjumping) 
- fc (forward checking)
- dvo (dynamic variable ordering) (πιο συγκεκριμένα mrv)


Βασισμένοι στα προαναφερθέντα papers, για κάθε μεταβλητή δημιουργούμε 
τα σύνολα conf-set και past-fc με βάση τα οποία επιλέγουμε ποια μεταβλητή 
αποδείχθηκε "προβληματική" και επομένως πρέπει να αφαιρεθεί ώστε να 
επιστρέψουμε στο σημείο πριν τοποθετηθεί αναιρώντας όλες τις ενδιάμεσες επιλογές.
Στο σύνολο past-fc αποθηκεύονται οι μεταβλητές οι οποίες έκαναν forward check 
στην εξεταζόμενη μεταβλητή, η τιμη τους δηλαδή επηρεασε το domain της εξεταζομενης μεταβλητης
ενώ από το σύνολο conf-set (που ενημερώνεται βάσει του past-fc στο unlabeling/fc) 
επιλέγεται η μεταβλητή στην οποία θα γίνει το backjump. Στο conf-set μιας μεταβλητής 
αποθηκεύονται όλα τα προηγούμενα conflict που ειχαν και λέξεις στις οποίες έκανε αυτή intersect.


Ακολουθούμε την εξής λογική:


1. Επιλέγουμε πάντα να συμπληρωθεί το variable (λέξη στο σταυρόλεξο) η οποία 
έχει τις λιγότερες επιλογές (mrv, domain size). Αυτό γίνεται με την συνάρτηση 
sum_bit η οποια υπολογιζει ποσοι άσοι υπάρχουν σε ενα bitmap 
το οποίο είναι ισοδύναμο με το πλήθος των λέξεων που μπορεί να μπουν σε αυτη τη θέση.


2. Το labeling (fc-cbj) (αναθεση value σε variable) γίνεται με τον παρακάτω αλγόριθμο:

    α. Βρίσκεται λέξη (value) από το λεξικό
    β. Αν το συγκεκριμενο value μηδενιζει καποιο απο τα domains των
    intersections, τοτε στο conf-set αυτου της εξεταζομενης λεξης
    αναθεσε την ενωση αυτου με το past-fc του intersection

    Αν η συνθηκη του β αληθευει τοτε τα βηματα γ εως ε παραλειπονται
    και ο αλγοριθμος ξεκιναει παλι απο το α με καινουργια τιμη του λεξικου
        
    γ. Αποθήκευσε τους χαρτες τους οποιους προκείται να επηρεασει το συγκεκριμενο value
    (μονο των intersections δηλαδη) στη στοιβα map_stack
    δ. Ενημέρωσε τους χαρτες αυτους βασει του value
    ε. Προσθεσε την εξεταζομενη μεταβλητη στο συνολο past-fc ολων των intersections


3. Το unlabeling (fc-cbj) (επιστροφη σε πρωιμη κατασταση) γίνεται με τον παρακάτω αλγόριθμο:

    1. Διαπιστώνουμε οτι η εξεταζομενη μεταβλητη (εστω Α) εχει κενο domain
    2. Βρες το μεγαλυτερο στοιχειο απο τα past-fc, conf-set της Α
    (τη πιο προσφατα τοποθετημενη μεταβλητη που υπαρχει σε αυτα τα συνολα, εστω B)
    3. Τοποθετησε στο conf-set της B την ενωση των συνολων past-fc, conf-set της Α
    4. Αφαιρεσε την Β απο το conf-set της Β

    Επομενως επιλεχθηκε η μεταβλητη Β ως προβληματικη 
    και θα επιστρεψουμε στην κατασταση πριν την αναθεση της

    Για ολες τις μεταβλητες απο το Α μεχρι το Β κανε
    5. Μηδενισε τα conf-set των μεταβλητων αυτων
    6. Επανεφερε απο τη στοιβα map_stack τους χαρτες στις πειραγμενες μεταβλητες
